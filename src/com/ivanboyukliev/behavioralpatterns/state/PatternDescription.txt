
                                                                                             VIII. State

1. Основна идея: Позволява на обекта да променя своето поведение, когато се промени вътрешното му състояние

-> Обикновено, ако трябва да променяме поведението на обект базирайки се на дадено негово състояние използваме if-else условни конструкции или switch - case. Със State шаблона те не са необходими.

-> Ние създаваме обекти, които представляват различни състояния и контекстен обект, чието поведение се променя с промяната на state обектите. По този начин се постига слаба свързаност. (loose copiling)

-> Шаблонът е подобен на Strategy шаблона

2. Кога да използваме шаблона?

-> Когато операциите имат големи, съставени от многочасти if-else условни конструкции, които зависят от дадено състояние на обекта. Състоянието обикновено е предствено чрез една или повече enum константи. Често няколко операции
   съдържат една и съща условна конструкция. Със State шаблона всяка условност се капсулира в отделен клас. Позволява третирането на състоянието на обекта по начин независим от oстаналите обекти.

3. Предимства

-> Много лесно се добавят състояния отразяващи допълнително поведение. Прави кодът по-гъвкав и подлежащ на лесна поддръжка.

4. Компоненти при реализацията на State шаблона

   1) Context : Дефинира интерфейса, който е от интерес за клиентите. Съдържа инстанция на ConcreteState, който дефинира текущото състояние.

   2) State : Дефинира интерфейс за капсулиране на поведението свързано с конкретно състояние на Context обекта.

   4) ConcreteState подкласове : всеки наследяващ клас имплементира поведение асоциирано със конкретно състояние на обекта.

5. Взаимодействия между компонентите

-> Context обектът делегира заявките, късаещи специфично негово поведение, на ConcreteState обекта (съдържа рефенция към ConcreteState).
-> Context обектът може да предаде своята референция като аргумент към метода за обслужване, който принадлежи на State класа.
-> Клиентите могат да конфигурират даден Context със State обекти. След като един път е конфигуриран Context-ът на клиентите не се налга повече директно да взаимодействат със State обектите.
-> Context обектът или самите ConcreteState обекти могат да преценят кое състояние е с приоритет пред останалите и при какви точно ситуации.
