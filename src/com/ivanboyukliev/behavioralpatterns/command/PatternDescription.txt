


                                                                                   II. Command

1. Общ поглед

-> Шаблонът има идеята да капсулира логиката, съдържаща се в една заявка формирана от страна на клиента. По този начин заявките могат да бъдат поставяни в опашка или лог.

-> Важна характеристика, че след изпълнение на дадена задача без проблем можем да се върнем към състоянието на системата преди изпълнението (request undoing)

-> Command обектът предоставя един метод execute(), в който се имплементира цялата логика и се запазва състоянието. Може да се добави и метод unexecute(), който да премахне последствията от изпълнението на execute();

-> Шаблонът предоставя възможност и за записване в лог на промeните в системата, така че при срив на системата да може да се върнем към състоянието преди срива

-> Шаблонът е data-driven

-> В дизайна може да има callback функция

-> Шаблонът е полезен при моделирането на транзакции.

-> Лесна разширяемост, тъй като могат да се добавят нови команди без да се променя съществуващият код.

-> Този шаблон ни позволява да изпращаме заявки към обекти, без да знаем нищо за операциите, които ще се изпълнят или за този, който ще ги изпълнява (decoupling).

-> При Chain of Responsibility шаблона не се знае кой точно е отговроен за изпълнението на заявката докато при Command е ясно.


2. Основни компоненти от дизайна на шаблона - Invoker, Client, Command, Receiver

   1) Command  - Декларира интерфейс за всички команди. Командата се извиква през нейния execute() метод и се обръща към Receiver обекта да изпълни същинското действие. Може да има undo() метод.
   2) ConcreteCommand - Дефинира връзката между Receiver обект и конкретно действие. Invoker прави заявка чрез извикването на execute() и този клас я изпълнява чрез извикването на един или няколко метод на Receiver.
   3) Client - създава ConcreteCommand обект и задавa неговия Receiver
   4) Invoker - наясно е само с интерфейса, който е предоствян от Command. Не знае за конкретните команди
   5) Receiver - знае какво трябва да направи, за да изпълни заявката. Всеки клас може да влезе в ролята на Receiver


3. Общ алгоритъм

-> Клиентът създава Receiver обект, след това ConcreteCommand обект. На конструктора на ConcreteCommand се подава Receiver обектът.

-> Клиентът създава Invoker обект, като на неговия конструктор подава ConcreteCommand обекта.

-> Invoker издава заявка като изивиква execute() метода на Command. Когато командите са обратими, ConcreteCommand съхранява предишното състояние преди извкването на execute().

-> Когато клиентската програма изпълни действието (чрез Invoker обекта), то се обработва от Command и Receiver обекта. ConcreteCommand обектът извиква подходящия метод на Receiver, който
   изпълнява същинската заявка.

4. Обобщение : цели се разделянето на извикващ(Invoker), командата(ConcreteCommand) и същинския и изпълнител (Receiver).