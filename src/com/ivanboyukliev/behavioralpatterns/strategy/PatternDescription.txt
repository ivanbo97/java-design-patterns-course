
                                                                                       VIV. Strategy

1. Основна идея : Шаблонът за дизайн Strategy дефинира 'семейства' от алгоритми, капсулира всеки от тях и ги прави взаимозаменяеми. Концептуално всички тези алгоритми правят едно и също, но имплементациите им са
                  различни.

-> Може да избираме поведението на даден алгоритъм динамично (at runtime).

-> Клиентското приложение указва чрез параметър на метод кой точно алгоритъм трябва да се изпълни.

-> Позволава ни да създаваме обекти, които представят различни стратегии контекстен обект, чието поведение в засимост от Strategy обекта.

2. Примери

-> Collection.sort() от Java API използва Strategy шаблона. Взема Comarator като параметър. В зависмост от различните имплементации на Comaprator интерфейса, обектите ще бъдат сортирани по различн начин


3. Strategy vs 	State pattern

-> При Strategy шаблона наследващите класове решават как да имплементират стъпките на даден алгоритъм

-> При State шаблона се слагат условия според контекста.

-> Различка между двата шаблона е, че при State шаблона Context класът съдържа референция към обекта капсулиращ състоянието. При Strategy, strategy обектът се предава аргумент на метод и контекстния обект
   не е необходимо да го капсулира.

4. Предимства

-> С капсулирането на алгоритъма отделно, могат да бъдат лесно добавяни нови алгоритми съобразяващи се със същия интерфейс.

-> Приложенията могат да сменят стратегии at run-time (полиморфизъм)

-> Позволява на клиентските класове да избират изисквания алгоритъм без да се използва "switch" изрази или серии от if-else конструкции.

-> Улеснява unit тестването, защото всеки алгоритъм е в отделен клас и може да бъде тествавн през неговия интерфейс самостоятелно.

5. Кога да се използва шаблонът?

-> Кога искаме да поддържаме различни вариванти на даден алгоритъм.

-> Когато алгоритъмът използва данни, за които клиентът не е нужно да знае.

6. Компоненти от имплементацията

   1) Strategy : Декларира интерфейс общ за всички имплементации на алгоритмите. Context класът използва този интерфейс, за да извика алгоритъма дефиниран от ConcreteStrategy.

   2) ConcreteStrategy : имплементация на Strategy интерфейса за конкретен алгоритъм

   3) Context : конфигуриран е с ConcreteStrategy обект, който се предава през метод като параметър или директно съдържа негова референция като даннов член.

 Context обектът изпраща получената от клиента заявка към Strategy обекта. Клиентът обикновено създава и подава ConcreteStrategy обект към Context обекта като параметър.