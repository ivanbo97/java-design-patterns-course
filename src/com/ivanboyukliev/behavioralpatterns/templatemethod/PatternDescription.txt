                                                                                      X. Template method

1. Основна идея : Дефинира "скелета" на алгоритъма в една операция, като позволява на наследяващите класове да дефинират конкретни стъпки от алгоритъма, но без да променят неговата структура.

-> Самото име template подсказва, че става дума за шаблон на даден алгоритъм. Шаблонът (template) е просто метод дефиниращ алгоритъма като множество от стъпки. Една или повече от тези стъпки се дефинират като
   абстрактни и трябва да се имплементират от наследващите класове.

-> Преизползваемостта е основната цел на шаблона. Затова се изолзва в много class libraries и frameworks

2. Кога е добре да се използва този шаблон?

-> Когато трябва да поддържаме няколко алгоритъма, които концептуално се държат по един и същ начин, но имат различни имплементации на стъпките им.
-> Когато искаме да избегнем дублиране на код. Шаблонът е добър пример за "refactoring to generalize". Първо се идентифицират разликите в съществуващия код и след това се разделят в нови операции. Разликите се
   заменят с template метод, който извиква една от тези нови операции.
-> Когато искаме да контролираме къде точно да се случва наследяването.

3. Поглед върху имплементацията

-> Този шаблон е използван много често в практиката и има много имплементации, които не изглеждат досущ като тези в учебниците по шаблони за дизайн.

-> !!! В повечете случаи това, което се случва е следното : Класовете наследници извикават методи принадлежащи на базовите класове. При Template method шаблона обаче е точно обратното.
       Родителските класове извикват методи от класовете наследници. Този механизъм е известен като Hollywood Principle - "don't call us, we'll call you."

-> Hollywood принципът ни насочва да правим избора в класовете от по-високо ниво кой модул от по-нискко ниво да извикаме.

-> Главният template метод е в базовия клас, който е абстрактен клас. Абстрактният клас може да дефинира конкретни методи, абстрактни методи и "куки". Абстрактните методи са имплементирани от класовете налседници.

-> "Кука"(hook) е метод, който е деклариран в абстрактния клас. Той има празна или default имплементация. Дава възможността на класовете наследници да се "закачат" за алгоритъма в рзлични точки. Класът наследник
    може спокойно да игнорира дадена кука.

4. Компоненти от имплементацията на шаблона

   1) AbstractClass : съдържа template метода и абстрактни версии на операциите използвани в template метода. Template метода дефинира "скелета" на алгоритъма. Той използва примитивни операции, за да имплементира
                      алгоритъма.

   2) ConcreteClass : имплементира абстрактните операции, които се извикват, когато templateMethod() има нужда от тях. Може да съществува няколко Concrete класове, всеки от тях имплементиращ пълния набор от операции,
                      изисквани от template method

-> Примитивните операции, които templateMethod() извиква могат да бъдат декларирани като protected. (подсигурява се, че ще бъдат извиквани само от template метода).
-> Самият template метод не трябва да бъде override-ван. Затова той се обявява като final.

5. Обобщение: Има четири различни типове методи използвани в родителския клас:

    1) concrete methods: стандартни напълон имплементирани методи, които ще се използват от класовете наследници(utility methods).
    2) abstract methods: нямат имплементация, и трябва да се разпишат от класовете наследници.
    3) hook methods: методи съдържащи default имплементация, която може да бъде override-ната от някои класове.
    4) template method : метод, който извиква споменатите по-горе, за да опише определен алгоритъм без да се фокусира върху имплементационни детайли (loose coupling). Трябва да бъде final, за да избегнем Overrid-ване в
                         наследниците.
