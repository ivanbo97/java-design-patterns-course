									     V. Prototype

1. Основна идея

-> Шаблонът за дизайн Prototype се отнася до създаването на дубликат на даден обект, като се стремим да не влияем на проиводителността на системата
-> Използва се, когато създаването на обект е "скъпоструваща" откъм заемане на системни ресурси опреация. Фокусът тук е върху намаляване на разходите по създаване на нова иснтанция
-> Предоставя се механизъм чрез, който може да се копира оригиналният обект в нов обект и след това да се модифицира съдържанието му според нуждите
-> Ключов аспект е, че клиентският код може да създава нови инстанции без да знае кой конкретен клас се инстанцира
-> Указва, че обектът който се копира трябва да предостави имплементация на функцията за копиране

2. Абстрактни пример

-> Да речем имаме оригинал на даден документ.Искаме да направим някакви промени по него, за да го видим как се ще изглежд с тях. Това, което правим е не да редактираме оригинала, а
  просто правим негово копие и там редактираме.

-> Да приемем, че имаме една версия на приложението, която функционира добре, но искаме да направим нововъведения. Вместо да градим системата от 0 и да добавяме нововъдения, можем да
   копираме това, което имаме от нея и на база него да правим добвките.

-> Да приемем, че имаме обект, през който се зарежда инфомация от БД. Ако искаме да правим модификации на данните не е добра идея всеки път наново да ги зареждаме от БД. Можем да кешраме
   обекта и да връщаме копие при последващи заявки.

3. Ситуации, в които може да се използва Prototype шаблонът

-> За инстанцииране на класове at run time (динамично)
-> Когато системата трябва да създаде нови обекти от различни типове в сложна йерархия от класове
-> Когато инстанциите на клас могат да имат няколко различни комбинации на състояние (Може би е по-удачно да се инсталират съответния брой прототипи и да ги клонираме, отколкото
   да се класът да се инстанциира ръчно всеки път с подходящото състояние)

4. Предимства

-> Скривата сложността по създаването на нови инстанции от клиента (абстрактност)
-> Дава опция на клиента да генерира обекти, чийто тип не е познат
-> В някои случаи копирането на обект е много по-ефективно от създването на нов
-> Ние може да добавяме или премахваме продукти повреме на изпълнението
-> Новите инстанции се създават с по-малкко разходи на ресурси

5. Недостатъци

-> Всеки наследяващ клас трябва да имплементира клониращия механизъм
-> Имплементацията на клониращия механизъм може да предизвика затруднения: Ако има обекти, които преднамерено не предоставят възможност за копиране или ако има някакъв вид кръгова референция
-> Java clonable интерфейсът има някои проблеми

6. Имплементация

  Когато имлементираме шаблона за дизайн Prototype трябва да съобразим следните компоненти:

  1) Prototype - декларира интерфейс за клониране на себе си
  2) ConcretePrototype - клас, който импелемнтира Prototype интерфейса и по-конкретно неговия clone() метод
  3) Client - създава нов обект като изсисква от Prototype обекта да се самоколонира без да се използва операторът new.