									     V. Prototype

1. Основна идея

-> Шаблонът за дизайн Prototype се отнася до създаването на дубликат на даден обект, като се стремим да не влияем на проиводителността на системата
-> Използва се, когато създаването на обект е "скъпоструваща" откъм заемане на системни ресурси опреация. Фокусът тук е върху намаляване на разходите по създаване на нова инстанция
-> Предоставя се механизъм, чрез който може да се копира оригиналният обект в нов обект и след това да се модифицира съдържанието му според нуждите
-> Ключов аспект е, че клиентският код може да създава нови инстанции без да знае кой конкретен клас се инстанцира
-> Указва, че обектът който се копира трябва да предостави имплементация на функцията за копиране

2. Абстрактни примери

-> Да речем имаме оригинал на даден документ. Искаме да направим някакви промени по него, за да го видим как се ще изглежда с тях. Това, което правим е не да редактираме оригинала, а
  просто правим негово копие и там редактираме.

-> Да приемем, че имаме една версия на приложението, която функционира добре, но искаме да направим нововъведения. Вместо да градим системата от 0 и да добавяме нововъдения, можем да
   копираме това, което имаме от нея и на база него да правим добавките.

-> Да приемем, че имаме обект, през който се зарежда инфомация от БД. Ако искаме да правим модификации на данните не е добра идея всеки път наново да ги зареждаме от БД. Можем да кешраме
   обекта и да връщаме копие при последващи заявки.

3. Ситуации, в които може да се използва Prototype шаблонът

-> За инстанцииране на класове at run time (динамично)
-> Когато системата трябва да създаде нови обекти от различни типове в сложна йерархия от класове
-> Когато инстанциите на клас могат да имат няколко различни комбинации на състояние (Може би е по-удачно да се инстанцират съответния брой прототипи и да ги клонираме, отколкото
   класът да се инстанцира ръчно всеки път с подходящото състояние)

4. Предимства

-> Скривата сложността по създаването на нови инстанции от клиента (абстрактност)
-> Дава опция на клиента да генерира обекти, чийто тип не е познат
-> В някои случаи копирането на обект е много по-ефективно от създването на нов
-> Ние може да добавяме или премахваме продукти повреме на изпълнението
-> Новите инстанции се създават с по-малко разходи на ресурси

5. Недостатъци

-> Всеки наследяващ клас трябва да имплементира клониращия механизъм
-> Имплементацията на клониращия механизъм може да предизвика затруднения: Ако има обекти, които преднамерено не предоставят възможност за копиране или ако има някакъв вид кръгова референция
-> Java clonable интерфейсът има някои проблеми

6. Имплементация

  Когато имлементираме шаблона за дизайн Prototype трябва да съобразим следните компоненти:

  1) Prototype - декларира интерфейс за клониране на себе си
  2) ConcretePrototype - клас, който импелемнтира Prototype интерфейса и по-конкретно неговия clone() метод
  3) Client - създава нов обект като изисква от Prototype обекта да се самоклонира без да се използва операторът new.


  Важно!!! : Този начин на имплементация винаги връща shallow копие. Това означава, че ако обектът капсулира в себе си референции към други обекти те няма да бъдат клонирани.
  Ако искаме да правим deep копие, ще трябва да следваме модела показан на долния пример.
  Пример:

  class Person implements Clonable {
	private String name;
        private City city;

	public Person clone() throws CloneNotSupportedException {
		Person clonedObj = (Person) super.clone();
                clonedObj.city = this.city.clone();
		return clonedObj;
  	}

  }

  7. Проблеми с използването на Clonable интерфейс

  -> Ако имплементираме clone() метода в класа наследник, то това със сигурност означава, че ще  трябва да го имплементираме и в базовия клас (заради super.clone())
  -> Не можем да манипулираме final полета в Object.clone(), защото final полетата могат да бъдат променяни през конструктори. Ако искаме всеки обект да има свое уникално id, тo това
     е невъзможно с Clonable интерфейса, запшото clone() не извиква конструктора.

  8. Алтернативи на Clonable интерфейса

  -> Copy Constructor
  -> Serialization